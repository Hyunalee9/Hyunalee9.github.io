---
title: " CALL ë¬¸, ë³µí•© íŠ¸ë¦¬ê±° ì´ì „ íŠ¸ë¦¬ê±° ë¶„ë¦¬  ìˆ˜í–‰ ì‘ì—… (GTT , PACKAGE SPEC)"
excerpt: "ì•„ì´í‹°ìœŒ 0617_(1) "
categories:
      - ORACLE11g
tags:
      - ORACLE11g
      - TIL
last-modified-at: 2025-06-17T21:02
---

â¡ íƒ€ í…Œì´ë¸” (jobs)ì˜ ìµœì†Ÿê°’, ìµœëŒ“ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ê¸‰ì—¬ ì •ë³´ ê²€ì‚¬ í”„ë¡œì‹œì € ìƒì„±

```sql
SELECT * FROM hr.jobs;
SELECT * FROM hr.emp;

--  íƒ€ í…Œì´ë¸” (jobs)ì˜ ìµœì†Ÿê°’, ìµœëŒ“ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ê¸‰ì—¬ ì •ë³´ ê²€ì‚¬ í”„ë¡œì‹œì € ìƒì„±
--  íƒ€ í…Œì´ë¸”ì— CHECK ì œì•½ì¡°ê±´ ê±¸ì–´ì„œ ê²€ì¦í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— í”„ë¡œì‹œì €ë¥¼ ì´ìš©í•œë‹¤. 

CREATE OR REPLACE PROCEDURE hr.check_sal_proc(p_job IN varchar2, p_sal IN number)
IS
    v_minsal number;
    v_maxsal number;
    
BEGIN

SELECT min_salary, max_salary
INTO v_minsal, v_maxsal
FROM hr.jobs
WHERE job_id = p_job;

IF p_sal < v_minsal OR p_sal > v_maxsal THEN
    RAISE_APPLICATION_ERROR(-20000, 'out of range');
ELSE 
    dbms_output.put_line(p_job||' '||v_minsal||' '||v_maxsal);
END IF;

END check_sal_proc;
/
```

â¡ CHECK ì œì•½ì¡°ê±´ í–‰ íŠ¸ë¦¬ê±°ë¡œ êµ¬í˜„ (**CALL**)

ğŸ“Œ CALL procedure_name(parameter_list); : 

â†’ **PL/SQL ë¸”ëŸ­ êµ¬ë¬¸ ì—†ì´ë„ í”„ë¡œì‹œì € í˜¸ì¶œ** 

```sql
-- salary, job_id ì— ëŒ€í•˜ì—¬ INSERT/UPDATE íŠ¸ëœì­ì…˜ ë°œìƒí•  ë•Œë§ˆë‹¤ 
-- DMLí›„ job_idì™€ 'AD_PRES' ê°€ ë‹¤ë¥¼ ê²½ìš° ì˜í–¥ì„ ë°›ì€ í–‰ì— ëŒ€í•´ì„œ 
-- í”„ë¡œì‹œì € í˜¸ì¶œ.
CREATE OR REPLACE TRIGGER hr.salary_check
AFTER INSERT OR UPDATE OF salary, job_id ON hr.emp
FOR EACH ROW
WHEN (NEW.job_id <> 'AD_PRES') -- ì¡°ê±´
CALL hr.check_sal_proc(:new.job_id, :new.salary) -- check_sal_procí”„ë¡œì‹œì €ë¥¼ í˜¸ì¶œ
/
```

â¡ ë³µí•© íŠ¸ë¦¬ê±° ì´ì „ì—ëŠ” GTTë¥¼ ì´ìš©í•´ì„œ 

```sql
-- í˜¹ì€ GLOBAL ë³€ìˆ˜ í‘œí˜„ -> PACKAGE SPECì„ ì´ìš©í•  ìˆ˜ë„ ìˆë‹¤.
CREATE GLOBAL TEMPORARY TABLE hr.job_view
ON COMMIT DELETE ROWS
AS
SELECT job_id, min(salary) minsal, max(salary) maxsal
FROM hr.emp
GROUP BY job_id;

INSERT INTO hr.job_view
SELECT job_id, min(salary) minsal, max(salary) maxsal
FROM hr.emp
GROUP BY job_id;

SELECT * FROM hr.job_view;

rollback;

-- BEFORE ë¬¸ì¥ íŠ¸ë¦¬ê±° ìƒì„±
CREATE OR REPLACE TRIGGER hr.check_salary_before
BEFORE
INSERT OR UPDATE OF salary, job_id ON hr.emp
BEGIN
    DELETE FROM hr.job_view;
    
    INSERT INTO hr.job_view
    SELECT job_id, min(salary) minsal, max(salary) maxsal
    FROM hr.emp
    GROUP BY job_id;
    
END check_salary_before;
/

-- AFTER í–‰ íŠ¸ë¦¬ê±°
CREATE OR REPLACE TRIGGER hr.check_salary
AFTER
INSERT OR UPDATE OF salary, job_id ON hr.emp
FOR EACH ROW
WHEN (NEW.job_id <> 'AD_PRES')
DECLARE
    v_minsal number;
    v_maxsal number;
BEGIN
    SELECT minsal, maxsal
    INTO v_minsal, v_maxsal
    FROM hr.job_view
    WHERE job_id = :NEW.job_id;
    
    
END check_salary;
/

DROP PROCEDURE check_salary_before PURGE;
DROP PROCEDURE check_salary PURGE;
```

â¡ PACKAGE SPEC ì´ìš©

```sql
CREATE OR REPLACE PACKAGE hr.job_pkg
IS
    TYPE emp_sal_type IS TABLE OF number INDEX BY varchar2(20);
    emp_min_sal emp_sal_type;
    emp_max_sal emp_sal_type;
END job_pkg;
/

CREATE OR REPLACE TRIGGER hr.check_salary_before
BEFORE
INSERT OR UPDATE OF salary, job_id ON hr.emp
BEGIN

-- BEFORE ë¬¸ì¥ íŠ¸ë¦¬ê±° 
   FOR i IN (SELECT job_id, min(salary) minsal, max(salary) maxsal
    FROM hr.emp
    GROUP BY job_id) LOOP
        hr.job_pkg.emp_min_sal(i.job_id) := i.minsal;
        hr.job_pkg.emp_max_sal(i.job_id) := i.maxsal;
   END LOOP;  
END  check_salary_before;
/

-- AFTER í–‰ íŠ¸ë¦¬ê±°
CREATE OR REPLACE TRIGGER hr.check_salary
AFTER 
INSERT OR UPDATE OF salary, job_id ON hr.emp
FOR EACH ROW
WHEN (NEW.job_id <> 'AD_PRES')
BEGIN
    IF :NEW.salary < hr.job_pkg.emp_min_sal(:NEW.job_id) OR :NEW.salary > hr.job_pkg.emp_max_sal(:NEW.job_id) THEN
        RAISE_APPLICATION_ERROR(-20000, 'out of range');
    END IF;
END check_salary;
```

â¡ ë‹¤ë¥¸ HR ì„¸ì…˜ì—ì„œ WRITE í•  ê²½ìš°, mutating ì—ëŸ¬ â†’ out of rangeë¡œ ëŒ€ì²´ ì—ëŸ¬.

```sql
INSERT INTO hr.emp(employee_id, last_name,salary, job_id, department_id) VALUES(300, 'ORACLE', 10000, 'IT_PROG' , 10);
```

![image.png](/assets/20250617/1.png)