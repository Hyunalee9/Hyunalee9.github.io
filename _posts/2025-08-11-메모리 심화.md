---
title: "[75일차] 메모리 심화 "
excerpt: "아이티윌 0811"
categories:
      - ORACLE11g
tags:
      - ORACLE11g
      - TIL
last-modified-at: 2025-08-11T21:08
---

# 메모리 심화

## Connection

▶️ 클라이언트가 데이터를 access 하기 위해서 SQL문을 던지려고 한다.

▶️ SQL Developer (user process) 를 이용해 Server process에 접근하려고 한다.

▶️ 접속 시도 시, 리스너(lister.ora) 가 클라이언트에게 전용 서버 프로세서를 생성하여 붙여준다.

▶️ 네트워크 정보 체크 ( 호스트, 포트 , 프로토콜, SID)

▶️ 클라이언트 쪽 연결 옵션에는 두 가지가 있다.

- Easy Connection : 클라이언트쪽에 네크워크 설정할 필요 없는 연결 방법 (ex. SQL Developer)
- 고급 연결 옵션 : 클라이언트쪽 네트워크를 구성해야만 하는 연결 방법 . tnsnames.ora 설정 (db link 만들때도 필요함)

▶️ **session** : user들이 오라클에 login한 상태 

## Cursor

▶️ cursor는 서버 프로세서 안에 pga 안에 uga 안에 있다.

▶️ cursor는 SQL문 실행 메모리 영역이다. 

▶️ uga안에는 sort작업을 처리하는 SQL 문 작업 영역도 있다.

## SELECT 문

▶️ 유저가 SELECT 문을 던지면, 

1. parse 단계
    - syntax check
    - semantic check - 유저, 객체, 객체 권한, 객체 타입, 세그먼트, 컬럼 체크)
    
    🌳 위 정보는 디스크의 시스템 테이블 스페이스의 데이터 딕셔너리 테이블에 저장되어있는데,
    
    물리적 i/o 많이 발생해서 data buffer cache에 저장. 자주 사용하는 정보들은 shared pool 의 데이터 딕셔너리(=row 단위로 쌓여있다고 해서 row cache)에 저장된다.  
    
    - 동일한 SQL 문이 library cahce안에 똑같은 SQL문이 있는지 실행계획이 있는지 체크
1. bind 단계
2. execute 단계 (물리적 블럭 i/o 발생 → data buffer cache)
    - library cache pin (lock) - shared 모드 (무효화가 되면 안되니까)
    - 테이블의 구조가 바뀌거나, 인덱스 변경, 통계 수집 등 발생하면  핸들과 실행 계획이 망가져 버린다.
    - 이때, 실행 계획은 무효화가 된다.
    
    🌳 타 세션의 ddl 작업 방지- library cache lock (wait event)  
    
    - active set 만든다.
3. Fetch
    - library cache lock =  null  (무효화가 필요할 때 빨리 ..)
    - librarh cache pin 패치

🌳 v$Libcache_locks

Lock/pin mode held:

- `0` - No lock/pin held
- `1` - Null mode
- `2` - Share mode
- `3` - Exclusive mode

## Latch

▶️ 유저가 SQL문을 던지면 서버 프로세서는 그 SQL문을 library cache에 있는 hash bucket 에 넣는데 이 전에 Latch를 잡아야 한다. → Latch library cache;

▶️ 파싱 → 핸들과 LCO를 설치하기 위한 메모리를 할당하기 위해서는 Shared Pool 이라는 Latch를 잡아야 한다.

▶️ CPU수가 4장 이상이고, SGA → 250m 이상이면 Latch 7개

▶️ 메모리 할당을 받으면, 핸들과 LCO를 생성. 나 혼자 작업해야하기 때문에 Library Cache Lock이라는 메커니즘을 잡아야 함. (exclusive mode) - 메모리 구성 (Library Cache Lock - null)

▶️ A, B 유저가 있다. A가 먼저 하드 파싱을 수행하는 동안에는 Library Cache Lock이라는 메커니즘이 B의 작업을 막는다.

▶️ 실행 계획 생성은 Library cache pin (exclusive mode) 찍어놓고 수행

## ⭐ 정리 - SGA (System Global Area)

- 모든 오라클 프로세스가 액세스하는 공유 메모리
- SGA 영역에 있는 구성 요소들은 DB 운영 중에 동적으로 설정할 수 있다.
- SGA 메모리는 SGA_MAX_SIZE (static parameter) 로 설정한다.

```sql
show sga

/*
Total System Global Area   713027608 bytes      
Fixed Size                   8900632 bytes      
Variable Size              587202560 bytes      
Database Buffers           109051904 bytes      
Redo Buffers                 7872512 bytes  
*/
```

📍 Fixed Size

- 백그라운드 프로세스가 액세스 해야 하는 데이터베이스 및 인스턴스 상태에 대한 정보
- 잠금 (lock)에 대한 정보와 같이 프로세스 간에 통신하는 정보
- Fixed Size는 오라클이 관리한다.

▶️ Variable Size = shared pool + large pool + java pool + streams pool

📍 shared pool

```sql
select count(*) from v$sgastat where pool = 'shared pool'; -- 1418
```

📍 library cache : SQL 문 실행에 관련된 모든 객체에 대한 정보 관리

- shared sql area : SQL 문장, Parse, tree, 실행 계획 (execution plan)
- pl/sql area : pl/sql 문장, 컴파일된 정보, source, p(parse)-code, m(machine)-code, errors
- handle + LCO(library cache object)
- handel = name (SQL문) + 메타정보
- LCO = dependency, child table, data block(실행 계획 정보)

📍 data dictionary cache (row cache) : 딕셔너리 정보들이 저장되어 있는 메모리 

```sql
select cache#, type, parameter from v$rowcache;
```

![image.png](/assets/20250811/1.png)

▶️ 데이터 딕셔너리 캐쉬안에 들어있는 정보들

- session, process, enqueue, transaction 정보
- shared server 환경을 사용하는 경우 UGA(User Global Area)
- shared_pool_size

▶️ SELECT 문 처리 단계

```sql
select * from hr.employees where employee_id = 100;
```

▶️ parse

- 문법 체크 (syntax)
- 의미 분석(semantic) 체크 : user$, obj$, tab$, seg$, col$, objauth$, sysauth$
    
    → 딕셔너리 정보가 있는 data dictionary cache 영역을 조회한다.
    

🌳 objauth$

```sql
select * from objauth$;
```

![image.png](/assets/20250811/2.png)

▶️ 알아보기 힘들어서 보기 쉽게 만든 뷰 (dba_tab_privs)

🌳 Soft parsing

- 동일한 SQL 문이 shared pool 메모리 안에 library cache 에 있는지 조회

→ 동일한 SQL문이 있으면 실행 계획을 공유하기 위해서 

→ library cache latch 를 획득한 후 조회해야 한다.

→ latch를 못잡을 경우 기다려야 한다. 이때 발생하는 wait event 는 latch : library cache 

→ latch(프로그램) 대신 mutex (프로그램) 형태가 나왔다. (10g)

🌳 library cache : mutex x 

🌳 soft parsing 실패하게 되면 hard parsing 발생한다.

- 메모리 할당
    - shared pool latch를 획득하고 적절한 크기의 free chunk를 free list에서 찾는다.
    - shared pool latch를 획득 못하는 latch : shared pool wait event 발생한다.

🌳 만약에 free 조각이 7k, 10k, 1k, 100byte 있는 경우 내가 필요한 프리 공간은 8k라면 이 중에 10k 프리 공간을 8k로 확보하고 남은 2k는 프리 공간으로 놔둔다. 후에 프리 공간은 7k, 2k, 1k, 100byte 로 남아 있다. 이때 또 필요한 프리 공간이 9k 라면 어떨까 ▶️ 내가 필요한 만큼의 프리 공간이 없으면 ORA-04031 오류 발생한다. (**단편화 발생**: 공간이 있지만 필요한 만큼의 공간은 없는 것.)

사용할 수 있는 프리 공간이 없이 조각들이 너무 많이 만들어져 있는 경우 ora-4031가 발생할 수 있는 경우가 빈번해 질 수 있다. 해결 방법은 shared pool를 flush 해야 한다. alter system flush shared_pool; 

select 문의 크기에 따라 LCO, handle 의 크기도 달라진다.

- free를 확보한 후 library cache handle에 대해 library cache lock을 exclusive 모드로 획득하고 LCO(Library Cache Obejct) 를 생성한다.
- LCO가 생성되면 library cache lock은 NULL 모드로 변환한다.
- library cache pin을 exclusive 모드로 획득한 후 실행 계획(execution plan) 을 생성한다.

▶️ bind(옵션)

- SQL문에 변수 처리가 되어 있으면 실제 값이 입력되는 단계

▶️ execute

- library cache lock 과 library cache pin을 shared 모드로 변환하고 블록 I/O 발생, ACTIVE SET 결과 생성

▶️ fetch

- library cache lock 을 null 모드 변환하고 library cache pin을 해제한다.
- active set 결과를 user process에 전달한다.

- 실행 계획
    
     ▶️ 데이터 처리 방법 결정 
    
    1. full table scan
    2. rowid scan
        - by user rowid
        - by index rowid
    
    ▶️ 조인 방법
    
    1. nested loop join
    2. sort merge join
    3. hash join

        ▶️ 조인 순서

- from 절에 나열되어 있는 테이블의 수만큼 순서를 결정해야 한다. (n!)

📍 동일한 SQL 문

- 공백문자, 줄바꿈, tab key 일치
- 대소문자
- 소유자 이름.테이블
- 주석(—,/* */), 힌트(/*+ full */)*
- 조건절 비교값

```sql
alter system flush shared_pool;

-- ▶️ hr session
select * from hr.employees where employee_id = 100;
```

![image.png](/assets/20250811/3.png)

```sql
-- ▶️ sys session (LCO 조회)
select sql_id, sql_text, parse_calls, loads, executions, hash_value, plan_hash_value
from v$sql
where sql_text like '%hr.employees%'
and sql_text not like '%v$sql%';

/*
-> 
현재 공유 풀(Shared Pool)에 캐싱된 SQL 중에서 hr.emp 테이블을 참조하는 SQL 문의 실행 
통계 정보를 조회하는 명령
*/
```

![image.png](/assets/20250811/4.png)

📍 parse calls 

📍 loads

📍 executions 

📍 plan_hash_value :  실행 계획에 대한 hash value

```sql
-- 실행 계획
select * from v$sql_plan where sql_id  = '2sgjc8u8ha0m4'

-- 불편하다.
-- 조금 더 편하게 format
select * from table(dbms_xplan.display_cursor('2sgjc8u8ha0m4'));
```

📍 access : 데이터가 있는 실제 블록을 읽기 전에 어떤 방법으로 블록을 읽을 것인가를 결정한다. 

즉 데이터가 있는 블록을 미리 알고 있을 때 보편적으로 rowid scan 방식

📍 filter : 데이터가 있는 실제 블록의 위치를 모르는 경우 즉 첫 번째 블록부터 마지막 블록까지 읽어 가면서 데이터를 찾는 방식, 보편적으로 full table scan

```sql
-- ▶️ hr session
select * from hr.employees where employee_id =100;
select * from hr.employees where employee_id =101;
select * from hr.employees where employee_id =102;
select * from hr.employees where employee_id =103;

-- ▶️ sys session
select sql_id, sql_text, parse_calls, loads, executions, hash_value, plan_hash_value 
from v$sql
where sql_text like '%hr.employees%'
and sql_text not like '%v$sql%';

/*
c2qq278mfcx26	select * from hr.employees where employee_id =103	1	1	1	652637254	1833546154
cnnnw37nqdkty	select * from hr.employees where employee_id =101	1	1	1	3915828030	1833546154
98159y3jq5tgn	select * from hr.employees where employee_id =102	1	1	1	3814909428	1833546154
2sgjc8u8ha0m4	select * from hr.employees where employee_id = 100	3	1	3	2433024612	1833546154
*/

-- LCO 4개 

```

▶️ 변수 처리

```sql
var b_id number
execute :b_id := 100
select * from hr.employees where employee_id = :b_id;

execute :b_id := 101
select * from hr.employees where employee_id = :b_id;

execute :b_id := 102
select * from hr.employees where employee_id = :b_id;

```

▶️ 

```sql
drop table hr.emp purge;
create table hr.emp as select * from hr.employees;
alter system flush shared_pool;
select last_name, salary from hr.emp where employee_id = 100;
select sql_id, sql_text, parse_calls, loads, executions, invalidations
from v$sql
where sql_text like '%hr.emp%'
and sql_text not like '%v$sql%';
```

![image.png](/assets/20250811/5.png)

```sql
select * from table(dbms_xplan.display_cursor('8qhp0dmv9q94d'));
```

![image.png](/assets/20250811/6.png)

▶️ 필터 술어

```sql
-- DDL 문장 수행
alter table hr.emp add constraint emp_id_pk primary key(employee_id);

select sql_id, sql_text, parse_calls, loads, executions, invalidations
from v$sql
where sql_text like '%hr.emp%'
and sql_text not like '%v$sql%';
```

![image.png](/assets/20250811/7.png)

▶️ DDL 문장 수행하여 실행 계획이 망가졌다. hard parsing 발생.

```sql
select last_name, salary from hr.emp where employee_id = 100;

select sql_id, sql_text, parse_calls, loads, executions, invalidations
from v$sql
where sql_text like '%hr.emp%'
and sql_text not like '%v$sql%';
```

▶️ 실행 계획 무효화가 발생한 SQL문장을 또 다시 사용한다면 

![image.png](/assets/20250811/8.png)

Loads가 증가된다. 즉, 실행 계획을 다시 만든다. 

```sql
alter table hr.emp drop primary key;

select sql_id, sql_text, parse_calls, loads, executions, invalidations
from v$sql
where sql_text like '%hr.emp%'
and sql_text not like '%v$sql%';
```

![image.png](/assets/20250811/9.png)

▶️ DDL 문장 수행 → 무효화 또 발생

```sql
create unique index hr.emp_idx on hr.emp(employee_id);

select sql_id, sql_text, parse_calls, loads, executions, invalidations
from v$sql
where sql_text like '%hr.emp%'
and sql_text not like '%v$sql%';
```

![image.png](/assets/20250811/10.png)

▶️ unique index 생성 → 무효화 발생하지 않음

```sql
alter table hr.emp add constraint emp_id_pk primary key(employee_id);
-- 아래와 같음
alter table hr.emp add constraint emp_id_pk primary key(employee_id) using index hr.emp_idx;
-- 또 unique index 발생
-- 무효화 발생하지 않음

select sql_id, sql_text, parse_calls, loads, executions, invalidations
from v$sql
where sql_text like '%hr.emp%'
and sql_text not like '%v$sql%';

select last_name, salary from hr.emp where employee_id = 100;
-- 무효화 발생
```

![image.png](/assets/20250811/11.png)

▶️ 테이블 구조 변경 → 무효화 발생

```sql
alter table hr.emp modify last_name varchar2(40);

select sql_id, sql_text, parse_calls, loads, executions, invalidations
from v$sql
where sql_text like '%hr.emp%'
and sql_text not like '%v$sql%';
```

▶️ select 문

```sql

select last_name, salary from hr.emp where employee_id = 100;

select sql_id, sql_text, parse_calls, loads, executions, invalidations
from v$sql
where sql_text like '%hr.emp%'
and sql_text not like '%v$sql%';
```

▶️  

```sql
select num_rows, blocks, avg_row_len, to_char(last_analyzed, 'yyyy-mm-dd hh24:mi:ss') from dba_tables where owner = 'HR' and table_name ='EMP';

-- last_analyzed : 마지막 통계 수집을 한 날짜.
```

![image.png](/assets/20250811/12.png)

📍 ctas 이용하면 대상 테이블은 통계 수집한다.

```sql
EXECUTE DBMS_STATS.GATHER_TABLE_STATS('HR','EMP');
```

📍 hidden 파라미터

```sql
select a.ksppinm parameter, b.ksppstvl value
from   x$ksppi a, x$ksppcv b
where  a.indx = b.indx
and    a.ksppinm = '_optimizer_invalidation_period';
```

![image.png](/assets/20250811/13.png)

▶️ library cache lock

- library cache lock 은 LCO(Library Cache Object)를 접근하거나 변경하는 경우 handle에 대해 획득하는 lock이다.
- 여러 세션에서 동시에 동일한 LCO를 변경하는 것을 방지하기 위해서 사용한다.
- library cache lock을 획득하지 못해 대기 하는 경우 library cache lock 이벤트가 발생한다.
- SQL hard parsing
    - library cache lock 은 exclusive mode로 획득해야 한다.
    - LCO를 생성하면 library cache lock은 null mode 변환한다.
- SQL execute 단계 : library cache lock 은 shared mode로 획득해야 한다.
- SQL fetch 단계 : library cache lock 은 null mode로 획득해야 한다.
- DDL 문장 : library cache lock은 exclusive mode로 획득해야 한다.
- create or replace procedure (function, package) : library cache lock은 exclusive mode로 획득해야 한다.

```sql
-- hr 세션 창 2개, sys 1개
-- ▶️ sess_1 (hr)
EXECUTE DBMS_APPLICATION_INFO.SET_CLIENT_INFO('sess_1');

-- ▶️ sess_2 (hr)
EXECUTE DBMS_APPLICATION_INFO.SET_CLIENT_INFO('sess_2');
-- ▶️ sys session
select client_info, sid from v$session where client_info in ('sess_1' , 'sess_2');
/*
SYS@ora19c> select client_info, sid from v$session where client_info in ('sess_1' , 'sess_2');

CLIENT_INFO                                                             SID
---------------------------------------------------------------- ----------
sess_1                                                                   36
sess_2                                                                  273

*/

-- 세션이 현재 대기하고 있는 이벤트 정보, 누적 정보가 아닌 실시간 정보이므로 반복적으로 조회해야 의미 있는 정보를 얻을 수 있다.
-- (1)
select sid, event, wait_class, wait_time, seconds_in_wait, state
from v$session_wait
where sid in (36,273);

-- 세션별 대기 이벤트의 누적 정보 
-- (2)
select sid, event, total_waits, time_waited from v$session_event where sid in (36,273);
```

![1)](/assets/20250811/14.png)

1)

![2)](/assets/20250811/15.png)

2)

📍 session_event : 누적 정보 ( 세션 on)

▶️ sid : 세션 id

▶️ event : 대기 이벤트 이름

▶️ log file sync :  commit, rollback 하면 lwgr 

▶️ total_waits : 전체 대기 횟수

▶️ time_waited : 전체 대기 시간 1/100초 단위

📍 session_wait : 실시간 현재 정보  (이미 지나간 event는 안보임) 

- 세션이 현재 대기하고 있는 이벤트 정보, 누적 정보가 아닌 실시간 정보이므로 반복적으로 조회해야 의미 있는 정보를 얻을 수 있다.

▶️  sid : 세션 id

▶️  event : 대기 이벤트

▶️ wait_class : 대기 이벤트 종류

▶️ wait_time : 대기 시간, state 컬럼의 값이 waited know time 일 경우에만 의미를 가진다.

- 단위는 1/100초, 11g wait_time, micro(1/1,000,000) 컬럼으로 대체한다.

▶️ seconds_in_wait : 대기 시간, state 컬럼의 값이 waiting일 경우에만 의미를 가진다. 단위는 1초

11g time_since_last_wait_micro(1/1,000,000) 컬럼으로 대체한다.

▶️ state : 대기 상태, 이 컬럼의 값이 waiting 일 경우에만 실제 대기하고 있는 중이다.

📍 **세션이 끊기면 사라진다.** 

```sql
-- ▶️ sess_1
execute dbms_application_info.set_client_info('sass_1')

-- sess_1 , sess_2 모두 같은 프로시저를 생성 (= LCO 생성) 하려고 해 경합이 일어났다.
begin
    for i in 1..10000 loop
        execute immediate 'create or replace procedure p1 is begin null; end;';
    end loop;
end;
/

-- ▶️ sess_2
execute dbms_application_info.set_client_info('sass_2')

begin
    for i in 1..10000 loop
        execute immediate 'create or replace procedure p1 is begin null; end;';
    end loop;
end;
/

select sid, event, total_waits, time_waited 
from v$session_event 
where sid in (36,273);

/*
       SID EVENT
---------- ----------------------------------------------------------------
WAIT_CLASS                                                        WAIT_TIME
---------------------------------------------------------------- ----------
SECONDS_IN_WAIT STATE
--------------- -------------------
        36 SQL*Net message from client
Idle                                                                      0
            168 WAITING

       273 SQL*Net message from client
Idle                                                                      0
            158 WAITING

       SID EVENT
---------- ----------------------------------------------------------------
WAIT_CLASS                                                        WAIT_TIME
---------------------------------------------------------------- ----------
SECONDS_IN_WAIT STATE
--------------- -------------------

SYS@ora19c> select sid, event, total_waits, time_waited
from v$session_event
where sid in (36,273);  2    3

*/
```

▶️ 누적 정보 (session_event)

![image.png](/assets/20250811/16.png)

📍 **S** → shared

📍 **X** → exclusive 

▶️ 조회

```sql
select sid, username, prev_sql_id, sql_id from v$session where sid in (36,273);
```

![image.png](/assets/20250811/17.png)

```sql
select sql_text from v$sql where sql_id = '39unwnghvw0vs';
```

![image.png](/assets/20250811/18.png)

📍 library cache pin

- LCO 접근하거나 변경하는 경우 LCO에 대해 획득하는 LOCK
- LCO 실행 정보를 보호 즉 실행 과정 동안 LCO 의 실행 정보가 변경되는 것을 방지한다.
- SQL문 hard parsing :  library cache pin을 exclusive mode 획득한 후 실행 계획을 생성
- SQL문 execute 단계 : library cache pin을 shared mode 획득
- SQL문 fetch 단계 : library cache pin 을 해제한다.
- procedure(function, package) 실행단계 : library cache pin을 shared mode 획득

```sql
alter procedure(function, package).. compile : library cache pin을 exclusive mode 획득
```

▶️ simulation

```sql
grant execute on dbms_lock to hr;
```

▶️ 프로시저 생성

```sql
create or replace procedure hr.pin_proc(p_time in number)
is
begin
	dbms_lock.sleep(p_time);
end;
/

-- 5초동안 기다려줘
execute hr.pin_proc(5)
```

▶️

```sql
-- sess_1
execute dbms_application_info.set_client_info('sass_1')

-- sess_2
execute dbms_application_info.set_client_info('sass_2')

-- sys
select client_info, sid from v$session where client_info in ('sass_1','sass_2');

-- sess_2
alter procedure hr.pin_proc compile;

-- sys
select sid, event, total_waits, time_waited
from v$session_event
where sid in (36,282);
```

![image.png](/assets/20250811/19.png)