---
title: "[71일차] rman 암호화 백업 "
excerpt: "아이티윌 0805"
categories:
      - ORACLE19c
tags:
      - ORACLE19c
      - TIL
last-modified-at: 2025-08-05T21:08
---

# rman 암호화 백업

▶️ rman 암호화 백업

- 디스크에 암호되는 백업 : Oracle Advanced Security 를 사용하여 암호화를 제공한다.
- 테이프에 암호되는 백업 : OSB (Oracle Secure Backup)를 사용하여 암호화를 제공하는 경우 OSB가 암호화 키를 관리한다.

▶️ rman 암호화 백업은 세 가지 암호화 모드를 지원한다.

- TDE(Transparent Data Encrytion) 키를 사용
- 암호화 모드 : RMAN 스크립트에서 SET ENCRYPTION ON INDENTIFIED BY password ONLY
- 이중 모드 : RMAN 스크립트에서 SET ENCRYPTION ON INDENTIFIED BY password

```sql
select * from v$encryption_wallet;

/*

WRL_TYPE
--------------------
WRL_PARAMETER
--------------------------------------------------------------------------------
STATUS                         WALLET_TYPE          WALLET_OR KEYSTORE FULLY_BAC
------------------------------ -------------------- --------- -------- ---------
    CON_ID
----------
FILE
/home/oracle/wallet/tde/
CLOSED                         UNKNOWN              SINGLE    NONE     UNDEFINED
         0

*/

>rman
list copy 
list backup;
show all;
```

▶️

```sql
-- TDE 백업
-- 암호화 비활성화
CONFIGURE ENCRYPTION FOR DATABASE OFF;
-- 암호화 활성화(지속적으로 사용)
CONFIGURE ENCRYPTION FOR DATABASE ON; 
-- 암호화 활성화 현재 SESSION에서만 사용
SET ENCRYPTION ON;   -- 일시적

list backup;
backup database;

-- 키스토어 close
administer key management set keystore close identified by "oracle1234"
select * from v$encrytion_wallet;
```

▶️ 장애 발생

```sql
! rm /u01/app/oracle/oradata/ORA19C/users01.dbf
```

▶️ 복구 작업 

```sql
alter database datafile '/u01/app/oracle/oradata/ORA19C/users01.dbf' offline;

-- keystore close 되어 있으면 백업본을 사용할 수 없다.
restore datafile 7;

administer key management set keystore open identified by "oracle1234"
select * from v$encrytion_wallet;
restore datafile 7;
recover datafile 7;
alter database datafile 7 online;

```

▶️ 이중 모드 (Dual Mode)

- TDE(Transparent Data Encryption) 와 비밀번호 기반 암호화를 함께 사용한다.
- 이중 모드로 백업본을 이용해서 복구 작업 시에 TDE 또는 비밀번호를 사용할 수 있다.

```sql

CONFIGURE ENCRYPTION FOR DATABASE OFF;

-- 활성화
CONFIGURE ENCRYPTION FOR DATABASE ON;
SET ENCRYPTION ON IDENTIFIED BY itwill;

delete backup;
backup database;
list backup;
```

▶️ close

```sql
-- 키스토어 close (sys)
administer key management set keystore close identified by "oracle1234"
select * from v$encrytion_wallet;
```

▶️ 복구 작업

```sql
alter database datafile '/u01/app/oracle/oradata/ORA19C/users01.dbf' offline;

-- keystore close 되어 있으면 백업본을 사용할 수 없다.
restore datafile 7;

administer key management set keystore open identified by "oracle1234"
select * from v$encrytion_wallet;
restore datafile 7;
recover datafile 7;
alter database datafile 7 online;
```

▶️ open

```sql
administer key management set keystore open identified by "itwll"
select * from v$envryption_wallet;
alter database datafile 7 online;
```

▶️ 패스워드를 이용해서 decryption

```sql
SET DECRYPTION IDENTIFIED BY ITWILL:
restore datafile 7;
recover datafile 7;
```

▶️ 암호화 백업본 체크

```sql
select handle, tag, encrypted from v$backup_piece where encrypted = 'YES';
```

▶️ 마지막 실습

```sql
-- 세션 끊고 나갔다 들어오기
select * from v$encryption_wallet;
```

▶️ password encryted backup

- RMAN SESSION 백업 수행하는 세션에서만 사용

```sql
SET ENCRYTION ON IDENTIFIED BY oracle ONLY;
backup as compressed backupset database; -- 암호화 , 압축
select handle, tag, encrypted from v$backup_piece where encrypted = 'YES';
```

▶️ 장애 발생

```sql
! rm /u01/app/oracle/oradata/ORA19C/users01.dbf
```

▶️ offline

```sql
alter database datafile '/u01/app/oracle/oradata/ORA19C/users01.dbf' offline;
```

▶️ 패스워드를 이용해서 decrytion

```sql
SET DECRYPTION IDENTIFIED BY oracle;
```

▶️ online

```sql
alter database datafile 7 online;
```

📍 컬럼 암호 

```sql
create table hr.emp tablespace users select * from hr.employees;
alter table hr.emp modify salary encrypt;
select * from dba_encrypted_columns where table_name ='EMP' and owner = 'HR';

-- 컬럼 암호화는 기본적으로 SALT가 추가되어 있다.
-- SALT : 암호문에 문자열을 추가해서 쉽게 해독하지 못하게..
```

![image.png](/assets/20250805/1.png)

▶️ 암호화 컬럼에 인덱스 생성 시 주의사항

- salt 되어 있으면 인덱스 생성할 수 없다.

```sql
alter table hr.emp modify salary encrypt no salt;
create index hr.emp_sal_idx on hr.emp(salary) tablespace users;
select * from dba_encrypted_columns where table_name = 'EMP' and owner = 'HR';
```

▶️ 컨트롤 파일이 깨지면 백업 정보가 유실된다. 

📍 Recovery Catalog

- **RMAN repository data** 는 항상 target database의 control file에 저장된다.
- **Recovery Catalog**는 별도의 데이터베이스에 백업 정보를 보관함으로 control file이 손실되었을 때 유용하다.
- 컨트롤 파일 기반 repository보다 오랫 동안 백업 정보를 저장할 수 있다.
- 단일 Recovery Catalog에 여러 target database의 정보를 저장할 수 있다.
- control file 데이터 복제
- 백업 스크립트 저장

📍 encryption 지우는 작업

```sql
shutdown immediate;
startup 
! rm -r wallet 
```

## 클론 디비

📍 새로운 디렉토리 생성 후 백업

```sql
cd rcdb
pwd
backup as compressed backupset format '/home/oracle/rcdv/%U_%T' database include current controlfile;
```

📍

```sql
-- 리두 로그
SELECT a.group#, b.sequence#, a.member, b.status, b.first_change#, b.first_time, b.next_change#, b.next_time
FROM v$logfile a, v$log b
WHERE a.group# = b.group#
ORDER BY b.group#;

alter system archive log current;
-- 아카이브 정보 체크 
select sequence#, name, first_change#, next_change# from v$archived_log;
! cp -v 아카이브 리두 파일 /home/oracle/rcdb
! ls -l /home/oracle/rcdb

```

📍pfile

```sql
create pfile='/home/oracle/rcdb/initrcdb.ora' from spfile;

vi initrcdb.ora

*.compatible='19.0.0'
*.control_files='/home/oracle/rcdb/control01.ctl'
*.db_name='rcdb'
*.log_archive_dest_1='location=/home/oracle/rcdb mandatory'
*.log_archive_format='arch_%t_%s_%r.arc'
*.undo_tablespace='UNDOTBS1'
db_file_name_convert=('/u01/app/oracle/oradata/ORA19C/','/home/oracle/rcdb/')
log_file_name_convert=('/u01/app/oracle/oradata/ORA19C/','/home/oracle/rcdb/')

cat initrcdb.ora
```

📍 clone kill 시키는 작업

```sql
ps -ef | grep clone
kill -9 백그라운드 프로세서 번호
echo $ORACLE_HOME
. oraenv
export ORACLE_SID=rcdb
ORACLE_SID = [oracle] ? rcdb
ORACLE_HOME = [/home/oracle] ? /u01/app/oracle/product/19.3.0/dbhome_1
The Oracle base remains unchanged with value /u01/app/oracle

startup pfile=/home/oracle/rcdb/initrcdb.ora nomount;
select instance_name, status from v$instance;
exit
rman auxiliary /
```

📍 작업형

```sql
run {
	duplicate database to 'rcdb'
	pfile='/home/oracle/rcdb/initrcdb.ora'
	backup location '/home/oracle/rcdb';
}
```

▶️ 

```sql
select instance_name, status from v$instance;
select dbid, name, log_mode from v$database;
```

▶️ recovery catalog 정보가 저장되는 테이블스페이스 생성 

▶️ rcdb

```sql
create tablespace rc_tbs datafile; '/home/oracle/rcdb/rc_tbs01.dbf' size 10m autoextend on;

select file_id, tablespace_name, file_name, bytes, maxbytes, autoextensible from dba_data_files;
```

▶️ recovery catalog 소유자 생성

```sql
create user re_user
identified by oracle
default tablespace rc_tbs
temporary tablespace temp
quota unlimited on rc_tbs;
```

▶️ recovery catalog 소유자에게 recovery_catalog_owner 롤을 부여

```sql
grant connect, resource, recovery_catalog_owner to rc_user; 
-- 확인.
select * from dba_role_privs where grantee = 'RC_USER';
```

▶️ 유저 접속

```sql
conn rc_user/oracle
select * from session_roles;
select * from role_sys_privs;
select * from role_tab_privs;
exit

. oraenv
>
>
su -
-- root 유저
vi /etc/oratab
G
i
yy
p

```

![image.png](/assets/20250805/2.png)

```sql
:wq
cat etc/oratab
exit
. oraenv
rcdb
echo $ORACLE_HOME
rman target /
exit
rman catalog rc_user/oracle
```

▶️ 카탈로그 생성

```sql
rman> create catalog;
exit

-- 창 하나 띄우기
```

📍 target database

```sql
. oraenv
-- 네트워크 세팅

cd $ORACLE_HOME/diag/network/admin
ls
vi tnsname.ora

--> 추가
rcdb =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = oracle)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = rcdb)
    )
  )
  
  tnsping rcdb
  lsnrctl status
  lsnrctl start
  lsnrctl status
  
  -- ora19c
  . oraenv
  echo $ORACLE_SID
 rman target / catalog rc user/oracle@rcdb;
```

▶️ 카탈로그 디비에 등록 작업

```sql
echo $ORACLE_SID  
sqlplus rc_user/oracle
select * from rc_database;  -- 정보 보이지 않는다.

-- recovery catalog에 target database 정보를 등록한다.
register database;

-- rcdb
select * from rc_database;
select * from rc_database_incarnation;
select db_name, tablespace_name, name from rc_datafile;

/*

| DB\_NAME | TABLESPACE\_NAME | 파일 경로                                      |
| -------- | ---------------- | ---------------------------------------------- |
| ORA19C   | SYSTEM           | `/u01/app/oracle/oradata/ORA19C/system01.dbf`  |
| ORA19C   | SYSAUX           | `/u01/app/oracle/oradata/ORA19C/sysaux01.dbf`  |
| ORA19C   | UNDOTBS1         | `/u01/app/oracle/oradata/ORA19C/undotbs01.dbf` |
| ORA19C   | USERS            | `/u01/app/oracle/oradata/ORA19C/users01.dbf`   |

*/

select * from rc_backup_piece;
-- target 쪽

list backup;

-- rcdb
select * from rc_backup_piece;

-- target
backup as compressed backupset database tag='tuesday';
list backup tag='tuesday';

-- rcdb
select * from rc_backup_piece;

-- 백업 정책?
-- rcdb
select * from rc_backup_piece;
rm /u01/app/oracle/oradata/ORA19C/control01.ctl
startup
shutdown immediate;
rman target / catalog rc_user/oracle@rcdb
list failure;

/*

| Failure ID | Priority | Summary                                                                | 의미                               |
| ---------- | -------- | ---------------------------------------------------------------------- | -------------------------------- |
| **10382**  | CRITICAL | Control file needs media recovery                                      | 컨트롤 파일이 손상되어 복구 필요.              |
| **10362**  | CRITICAL | Control file `/u01/app/oracle/oradata/ORA19C/control01.ctl` is missing | 제어 파일이 아예 존재하지 않음.               |
| **148**    | HIGH     | One or more non-system datafiles need media recovery                   | SYSTEM이 아닌 일부 데이터 파일이 미디어 복구 필요. |

*/

-- 카탈로그 디비 백업 정보는 사라지지 않았다.
-- 기존
restore controlfile from autobackup;
restore controlfile from '컨트롤 파일 백업 물리적 경로'

-- 카탈로그 디비
restore controlfile;
alter database mount;
recover database;  -- 리두 정보 적용  (백업 컨트롤 파일을 이용해서 mount 올렸기 때문에 SCN 맞추는 작업)
alter database open resetlogs;  -- 혹은 재생성하면 된다.
list incarnation;
```

▶️ rcdb

```sql
select * from rc_database_incarnation;

-- 저장되어 있는 스크립트 확인
select * from rc_stored_script;

-- 저장되어 있는 스크립트 소스 확인
select * from rc_stored_script_line;

exit;

-- target db
rman target / catalog rc_user/oracle@rcdb

-- 스크립트 생성
create script incr_0_backup {
		backup as compressed backupset incremental level 0 database include current controlfile;
		alter system archive log current;
}

-- 현재 생성되어 있는 스크립트 이름
list script names;
print script incr_0_backup;

-- rcdb
-- 저장되어 있는 스크립트 확인
select * from rc_stored_script;
/*
| DB\_KEY | DB\_NAME | SCRIPT\_NAME    | SCRIPT\_COMMENT |
| ------- | -------- | --------------- | --------------- |
| 1       | ORA19C   | incr\_0\_backup | (비어 있음)         |
*/

-- 저장되어 있는 스크립트 소스 확인 
select * from rc_stored_script_line;
/*
DB_KEY  SCRIPT_NAME     LINE TEXT
------- -------------------- ----------------------------------------------------------------
1       incr_0_backup   1    {
1       incr_0_backup   2    backup as compressed backupset incremental level 0 database
                               include current controlfile;
1       incr_0_backup   3    alter system archive log current;}
*/		
```

📍 target db

▶️ 스크립트 실행

```sql
run {execute script incr_0_backup;}
```

▶️ 스크립트 수정

```sql
replace script incr_0_backup {
	backup as compressed backupset incremental level 0 database include current controlfile;
	alter system arhive log current;
}

print script incr_0_backup;
```

▶️ 스크립트 삭제

```sql
delete script incr_0_backup;
```

📍 target db

```sql
create tablespace insa_tbs datafile '/u01/app/oracle/oradata/ORA19C/insa_tbs01.dbf' size 5m;
```

📍 rcdb

```sql
select db_name, tablespace_name, name from rc_datafiles;
select DBINC_KEY, db_name, tablespace_name, name from rc_datafile;

/*

DBINC_KEY  DB_NAME   TABLESPACE_NAME   NAME
---------- --------- ----------------- -----------------------------------------------
2          ORA19C    SYSTEM            /u01/app/oracle/oradata/ORA19C/system01.dbf   -- 과거 정보
2          ORA19C    SYSAUX            /u01/app/oracle/oradata/ORA19C/sysaux01.dbf
2          ORA19C    UNDOTBS1          /u01/app/oracle/oradata/ORA19C/undotbs01.dbf
2          ORA19C    USERS             /u01/app/oracle/oradata/ORA19C/users01.dbf
334        ORA19C    SYSTEM            /u01/app/oracle/oradata/ORA19C/system01.dbf   -- 현재 정보
334        ORA19C    SYSAUX            /u01/app/oracle/oradata/ORA19C/sysaux01.dbf
334        ORA19C    UNDOTBS1          /u01/app/oracle/oradata/ORA19C/undotbs01.dbf
334        ORA19C    USERS             /u01/app/oracle/oradata/ORA19C/users01.dbf

*/
```

📍 재동기화 (resynchronize) 

- target 데이터베이스에 테이블스페이스를 생성, 추가, 삭제
- target 데이터베이스에 데이터 파일 추가, 삭제
- target 데이터베이스에 데이터 파일 재배치

```sql
rman target / catalog rc_user/oracle@rcdb
resync catalog -- 재동기
```

▶️ target db

```sql
alter tablespace insa_tbs add datafile /u01/app/oracle/oradata/ORA19C/insa_tbs02.dbf' size 5m;
```

▶️ rcdb

```sql
select DBINC_KEY, db_name, tablespace_name, name from rc_datafile;

report schema;
resync catalog;
select DBINC_KEY, db_name, tablespace_name, name from rc_datafile where dbinc_key = 334;

/*

DBINC_KEY  DB_NAME   TABLESPACE_NAME   NAME
---------- --------- ----------------- ---------------------------------------------------
334        ORA19C    SYSTEM            /u01/app/oracle/oradata/ORA19C/system01.dbf
334        ORA19C    SYSAUX            /u01/app/oracle/oradata/ORA19C/sysaux01.dbf
334        ORA19C    UNDOTBS1          /u01/app/oracle/oradata/ORA19C/undotbs01.dbf
334        ORA19C    USERS             /u01/app/oracle/oradata/ORA19C/users01.dbf
334        ORA19C    INSA_TBS          /u01/app/oracle/oradata/ORA19C/insa_tbs02.dbf
334        ORA19C    INSA_TBS          /u01/app/oracle/oradata/ORA19C/insa_tbs01.dbf

*/
```

▶️ target db

```sql
drop tablespace insa_tbs including contents and datafiles;
resync catalog; --drop이 잘 되지 않아서.
```

▶️ catalog 삭제

```sql
drop catalog;
-- Enter DROP CATALOG command again to confirm catalog removal
drop catalog; --진짜 삭제

exit 
sqlplus rc_user/oracle

-- rc 유저 
select DBINC_KEY, db_name, tablespace_name, name from rc_datafile where dbinc_key = 334;
exit
rman target /

-- 카탈로그 디비 정상적으로 삭제됨.
/*
connected to target database: ORA19C (DBID=1257496535)
connected to recovery catalog database
*/
```