---
title: "[76일차] 퍼포먼스 튜닝 "
excerpt: "아이티윌 0812_(1)"
categories:
      - ORACLE19c
tags:
      - ORACLE19c
      - TIL
last-modified-at: 2025-08-12T21:08
---

# 퍼포먼스 튜닝

📍 **shared pool latch**

- hard parsing 이 발생하는 경우 프리 청크를 찾기 위해 free list를 탐색하고 적절한 chunk를 할당하고 필요한 경우 프리 청크를 분할(split)하는 일련의 작업들은 모두 shared pool latch를 획득한 후에만 가능하다. shared pool latch를 획득하는 과정에서 경합이 발생하면 latch: shared pool 이벤트를 대기한다.
- shared pool latch는 기본적으로 인스턴스에 하나만 존재한다.
- 9i 버전부터는 shared pool 을 여러 개의 서브 풀로 최대 7개까지 나누어서 관리하며 오라클은 cpu 개수가 4개 이상이고 shared pool의 크기가 250m 이상인 경우 *kghdsidx_count 파라미터 값만큼 서브 풀을 생성해서 관리한다.*
- 각 서브풀마다 latch가 만들어지기 때문에 shared pool latch의 경합을 줄일 수 있다.

```sql
SYS@ora19c> select a.ksppinm parameter, b.ksppstvl value
from x$ksppi a, x$ksppcv b
where a.indx = b.indx
and a.ksppinm = '_kghdsidx_count';
```

![image.png](/assets/20250812/1.png)

```sql
select name, gets from v$latch_children where name = 'shared pool';
-- v$ ~ : db가 내려갔다 올라올 때부터 누적된 데이터 보여준다.
```

![image.png](/assets/20250812/2.png)

```sql
show parameter cpu_count

/*

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
cpu_count                            integer     2

*/
```

📍version count

- 자식 LCO (Library Cache Object) 수
- 버전 카운트가 증가하는 경우는 53가지가 있다. v$sql_shared_cursor;

```sql
-- Y를 찾아라
select * from v$sql_shared_cursor;
```

![image.png](/assets/20250812/3.png)

```sql
alter system flush shared_pool; 

-- ▶️ hr 세션
var name varchar2(10)
execute :name := 'King'
print name 

/*
NAME
--------------------------------
King
*/

select last_name, salary from hr.employees where last_name = :name;

-- 똑같은 세션에서 bind 변수 똑같이. 크기는 다르게 -> 이렇게 하면 안됨.
var name varchar2(1000) -- 하나의 세션에서 bind 변수를 다시 선언하면 안된다.
execute :name := 'King'
print name

select last_name, salary from hr.employees where last_name = :name;

select sql_id, sql_text, version_count
from v$sqlarea
where sql_text like '%hr.employees%'
and sql_text not like '%v$sqlarea%';
-- version_count 2 (child table) 개더라도 main table까지 고려하면 3이다.
```

![image.png](/assets/20250812/4.png)

```sql
select * from v$sql_shared_cursor where sql_id = 'gqgwd5rvu5ftu';
```

```sql
select address, child_address, child_number, bind_length_upgradeable from v$sql_shared_cursor where sql_id = 'gqgwd5rvu5ftu'
```

![image.png](/assets/20250812/5.png)

```sql
select address, child_address, child_number, datatype_string, max_length, value_string
from v$sql_bind_capture
where sql_id = 'gqgwd5rvu5ftu';
```

![image.png](/assets/20250812/6.png)

📍 varchar2 size(32, 128, 2000, 4000) 4가지 크기로 결정된다.

```sql
select * from table(dbms_xplan.display_cursor('gqgwd5rvu5ftu', 0));
select * from table(dbms_xplan.display_cursor('gqgwd5rvu5ftu', 1));

/*
---------------------------------------------------------------------------------------------------
| Id  | Operation                           | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |             |       |       |     2 (100)|          |
|   1 |  TABLE ACCESS BY INDEX ROWID BATCHED| EMPLOYEES   |     1 |    12 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN                  | EMP_NAME_IX |     1 |       |     1   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------------

*/

-- ▶️ 역으로 처음부터 큰 값을 적용하다, 작은 값으로 변경 -> sharing 하지 않음. 
```

📍 특정 cursor를 purge (11g)

```sql
select sql_id, sql_text, version_count ,address, hash_value
from v$sqlarea
where sql_text like '%hr.employees%'
and sql_text not like '%v$sqlarea%';
                                -- address        --hash value    
 execute dbms_shared_pool.purge('0000000063C6CF88,4154637114','c')
```

Purge할 객체 타입

- `'c'` : 커서(cursor)
- `'p'` : PL/SQL 패키지
- `'r'` : 프로시저(procedure)
- `'t'` : 트리거(trigger)
- `'q'` : 시퀀스(sequence)
- `'f'` : 함수(function)

📍 **과도한 hard parsing 문제점**

- 실행 계획 생성시에 과다한 CPU, 메모리 사용량 증가
- library cache chain의 확장으로 인한 검색시간 증가, mutex 점유 시간 증가
- shared pool fragmentation(단편화) : chunk가 작은 크기로 쪼개져서 chunk 수가 증가하는 현상, 따라서 체인의 길이를 증가시켜 체인 검색 속도 저하 유발, 하드 파싱시 필요한 청크 찾지 못하는 문제 발생 (ORA-4031) 확률이 높아 진다.

📍 **row cache lock**

- data dictionary cache (row cache) 는 오라클 데이터 딕셔너리 정보에 대한 cache 영역
- 유저, 객체, 테이블, 세그먼트, 컬럼, 인덱스, 시퀀스, 뷰, 함수, 프로시저, 패키지, 트리거,…
- DDL 작업을 수행하면 딕셔너리 정보에 대한 입력, 수정, 삭제
- semantic 체크시에 딕셔너리 정보를 이용해서 체크한다.
- row cache lock은 dictionary object를 보호하는 시스템 lock이다.

```sql
select pool, name, bytes from v$sgastat where name = 'row cache';
select cache#, type, parameter from v$rowcache;

/*
  CACHE# TYPE        PARAMETER
---------- ----------- --------------------------------
        13 PARENT      **dc_sequences**     <<- low cache lock이라는 이벤트가 일어난다.
        16 PARENT      dc_histogram_defs
        54 PARENT      dc_sql_prs_errors
        32 PARENT      kqlsubheap_object
        19 PARENT      dc_table_scns
        18 PARENT      dc_outlines
        15 PARENT      dc_props
        60 PARENT      dc_cdbprops
        14 PARENT      dc_profiles
        47 PARENT      realm cache
        48 PARENT      Command rule cache
*/

-- ▶️ hr session
create sequence hr.seq_1 nocache;

-- 정보 확인
select * from dba_sequences where sequence_owner = 'HR' and sequence_name = 'SEQ_1';

-- sess_1
exec dbms_application_info.set_client_info('sess_1')

declare
		v_value number;
begin
		for i in 1.. 100000 loop
			select hr.seq_1.nextval into v_value from dual;
		end loop;
end;
/

select hr.seq_1.nextval from dual;

-- sess_2 
exec dbms_application_info.set_client_info('sess_2')

declare
		v_value number;
begin
		for i in 1.. 100000 loop
			select hr.seq_1.nextval into v_value from dual;
		end loop;
end;
/

-- sys
select sid, event, wait_class, wait_time, seconds_in_wait, state from v$session where client_info in ('sess_1', 'sess_2');

select h.address, h.saddr, s.sid, h.lock_mode from v$rowcache_parent h, v$rowcache_parent w, v$session s where h.address = w.address and w.saddr = (select saddr from v$session where event = 'row cache lock' and rownum = 1) and h.saddr = s.saddr and h.lock_mode > 0;
```

▶️

```sql
select prev_sql_addr from v$session where sid = sid 이름

select * from dba_sequences where sequence_owner = 'HR' and sequence_name = 'SEQ_1';
```

▶️ row cache lock 경합 중에 sequence nocache 속성으로 인해 많이 발생한다.

- nextval 수행할 때마다 딕셔너리 정보를 변경하기 위해서 ssx(shared sub exclusive 5) 모드를 획득해야 함으로 경합이 발생한다.
- 해결 방법
    - cache 속성으로 수정해야 한다.
    
    ```sql
    alter sequence hr.seq_1 cache 100;
    ```
    

▶️ cache size 20 , 100 비교 

![image.png](/assets/20250812/7.png)

**20** → 이런 wait event 발생

📍 enq : SQ - contention : cache 크기가 작게 생성된 경우

**100** → 이벤트 발생하지 않음

▶️ 만약, 100에서도 발생한다?

🌳 shared pool (LRU 알고리즘 : 가장 최근까지 잘 사용하지 않는 데이터 업데이트)

📍Database Buffer Cache (Data Buffer Cache)

- 오라클은 물리적인 I/O 를 최소화하기 위해 최근에 사용된 블록을 메모리의 일정 영역에 보관한다. 이 메모리 영역을 데이터 버퍼 캐시라고 한다.

```sql
select * from hr.employees where employee_id = 100;
```

1️⃣ parse

2️⃣ bind

3️⃣ execute

- library cache lock 과 library cache pin을 shared 모드로 변환한다.
- 실행 계획을 이용해서 BLOCK I/O 발생
    - 요청한 블록의 DBA (Data Block Address) 와 Block class (블록 종류) 에 대해 해시 함수를 적용한 결과를 이용해서 hash bucket을 찾는다.
    - hash bucket 같은 해시 값을 갖는 버퍼 헤더 (buffer header) 들이 체인(chain) 형태로 구성되어 있다.
    - 버퍼 헤더 (buffer header)는 버퍼에 메타 정보를 가지고 있으며 버퍼 메모리 영역의 실제 위치 정보를 가지고 있다.
    - hash bucket 은 shared pool에서 관리한다.
    - 해시값에 해당하는 hash bucket을 검색하기 위해서는 latch 획득해야 한다. 이때 latch에 경합이 발생할 경우 latch: cache buffers chains 이벤트 발생한다.

```sql
select count(*) from v$latch_children where name = 'cache buffers chains';
```

![image.png](/assets/20250812/8.png)

```sql
select a.ksppinm parameter, b.ksppstvl value
from x$ksppi a, x$ksppcv b
where a.indx = b.indx
and a.ksppinm = '_db_block_hash_latches';

-- _db_block_hash_latches	1024
```

▶️ hash bucket 수

```sql
 select a.ksppinm parameter, b.ksppstvl value
from x$ksppi a, x$ksppcv b
where a.indx = b.indx
and a.ksppinm = '_db_block_hash_buckets';

-- _db_block_hash_buckets	32768
```

▶️ 하나의 latch가 담당하는 bucket 수  : 131072/1024 = 128

📍 hash bucket을 보호하는 cache buffers chains latch

- 읽기 작업 : shared mode
- 쓰기 작업 : exclusive mode

이 과정에서 경합이 발생하면 latch : cache buffers chains 이벤트가 발생한다.

📍 논리적(logical) I/O (총 읽어들인 블록의 수)  - access한 블록의 수 (ex. 4) 

- 블록 I/O (**물리적 I/O 포함**)

📍 물리적(physical) I/O  (블록 I/O)  (ex.1) : 메모리에 없어 디스크에서 올린 수 

- access하려는 블록이 메모리에 없을 경우

▶️ 총 읽어들인 블록의 수 4

▶️ 하드 파싱과 물리적 I/O와는 별개이다.